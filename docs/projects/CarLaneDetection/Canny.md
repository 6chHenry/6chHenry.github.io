# Canny Edge Detector

## 图像灰度化

读取图像(plt/cv2读的都是BGR) ------>转换为RGB格式----->任一点灰度值可以用平均法 / 权重计算

Gray(i,j) = [R(i,j) + G(i,j) + B(i,j)] / 3

or    Gray(i,j) = 0.299 * R(i,j) + 0.587 * G(i,j) + 0.114 * B(i,j)

## 高斯模糊

用离散版本的高斯函数（类似正态分布）

$H(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}}$

对于图像中的离散点,$(2k+1)\times (2k+1)$的卷积核,每个卷积核的中心点为(k+1,k+1),卷积核每个位置的值按照如下方式计算：

$H[i,j]=\frac{1}{2\pi\sigma^2}e^{-\frac{(i-k-1)^2+(j-k-1)^2}{2\sigma^2}}$

将这个卷积核与原图像进行卷积，得到的就是高斯模糊后的图片。

---

**补充说明！！！**

对于cv2/plt.imread()，读取返回的shape为Height,Weight,ColorChannel,其中color顺序为BGR

而查看Windows图片属性中像素形状为Weight * Height

用torch.ToTensor()会把形状转化为ColorChannel,Height,Weight,其中color顺序为BGR

plt.show()按照RGB格式顺序

参考文章：[python读取图片的几种方式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/402833064)

如果实在搞不懂可以多尝试！

---

## 图像梯度计算

常用方法：Sobel核进行卷积

简单版本：用相邻元素的像素值作差即可。

---

图像的坐标、数组访问、笛卡尔坐标是三套独立的东西。

图像坐标：以图像左上角为原点，向右为x轴正半轴，向下为y轴正半轴，$y\in (0,Height),x\in (0,Width)$

​	          计算梯度的时候也是以这个为准的，向右，向下，dx水平，dy竖直

数组访问：不要按照坐标的方式理解，否则容易乱套！i+1行在第i行的下边，j+1列在第j列的右边

计算梯度需要将数组和图像结合（因为图像实际存储在数组当中），计算dy时要用[i+1,j]-[i,j]，计算dx时要用[i,j+1]-[i,j]

笛卡尔坐标：向上为y轴正半轴，向右为x轴正半轴。

---

梯度方向是由x，y方向的梯度共同决定的，绝大多数时候都不会是竖直/水平的，因此与周围点网格(3*3)的交点不会在顶点处，交点为“亚像素”，需要用插值法计算亚像素的梯度。通过相邻两个点的梯度乘权重计算。

## 双阈值检测

高于阈值的即为边缘；低于阈值的即为非边缘；处于二者之间的，还要判断是否有可靠性边缘连接。



​	

